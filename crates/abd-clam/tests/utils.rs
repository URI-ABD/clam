//! Tests for the utility functions in `abd-clam`.

use abd_clam::utils;
use rand::prelude::*;
use symagen::random_data;

#[test]
fn test_transpose() {
    // Input data: 3 rows x 6 columns
    let data: Vec<[f64; 6]> = vec![
        [2.0, 3.0, 5.0, 7.0, 11.0, 13.0],
        [4.0, 3.0, 5.0, 9.0, 10.0, 15.0],
        [6.0, 2.0, 8.0, 11.0, 9.0, 11.0],
    ];

    // Expected transposed data: 6 rows x 3 columns
    let expected_transposed: [Vec<f64>; 6] = [
        vec![2.0, 4.0, 6.0],
        vec![3.0, 3.0, 2.0],
        vec![5.0, 5.0, 8.0],
        vec![7.0, 9.0, 11.0],
        vec![11.0, 10.0, 9.0],
        vec![13.0, 15.0, 11.0],
    ];

    let transposed_data = utils::rows_to_cols(&data);

    // Check if the transposed data matches the expected result
    for i in 0..6 {
        assert_eq!(transposed_data[i], expected_transposed[i]);
    }
}

#[test]
fn test_means() {
    let all_ratios: Vec<[f64; 6]> = vec![
        [2.0, 4.0, 5.0, 6.0, 9.0, 15.0],
        [3.0, 3.0, 6.0, 4.0, 7.0, 10.0],
        [5.0, 5.0, 8.0, 8.0, 8.0, 1.0],
    ];

    let transposed = utils::rows_to_cols(&all_ratios);
    let means = utils::calc_row_means(&transposed);

    let expected_means: [f64; 6] = [
        3.333_333_333_333_333_5,
        4.0,
        6.333_333_333_333_334,
        6.0,
        8.0,
        8.666_666_666_666_668,
    ];

    means
        .iter()
        .zip(expected_means.iter())
        .for_each(|(&a, &b)| assert!(float_cmp::approx_eq!(f64, a, b, ulps = 2), "{a}, {b} not equal"));
}

#[test]
fn test_sds() {
    let all_ratios: Vec<[f64; 6]> = vec![
        [2.0, 4.0, 5.0, 6.0, 9.0, 15.0],
        [3.0, 3.0, 6.0, 4.0, 7.0, 10.0],
        [5.0, 5.0, 8.0, 8.0, 8.0, 1.0],
    ];

    let expected_standard_deviations: [f64; 6] = [
        1.247_219_128_924_6,
        0.816_496_580_927_73,
        1.247_219_128_924_6,
        1.632_993_161_855_5,
        0.816_496_580_927_73,
        5.792_715_732_327_6,
    ];
    let sds = utils::calc_row_sds(&utils::rows_to_cols(&all_ratios));

    sds.iter()
        .zip(expected_standard_deviations.iter())
        .for_each(|(&a, &b)| {
            assert!(
                float_cmp::approx_eq!(f64, a, b, epsilon = 0.000_000_03),
                "{a}, {b} not equal"
            );
        });
}

#[test]
fn test_mean_variance() {
    // Some synthetic cases to test edge results
    let mut test_cases: Vec<Vec<f64>> = vec![
        vec![0.0],
        vec![0.0, 0.0],
        vec![1.0],
        vec![1.0, 2.0],
        vec![0.0, 0.25, 0.25, 1.25, 1.5, 1.75, 2.75, 3.25],
    ];

    // Use cardinalities of 1, 2, 1000, 100_000 and then 1_000_000 - 10_000_000 in steps of 1_000_000
    let cardinalities = vec![1, 2, 1_000, 100_000]
        .into_iter()
        .chain((1..=10).map(|i| i * 1_000_000))
        .collect::<Vec<_>>();

    // Ranges for the values generated by SyMaGen
    let ranges = vec![
        (-100_000., 0.),
        (-10_000., 0.),
        (-1_000., 0.),
        (0., 1_000.),
        (0., 10_000.),
        (0., 100_000.),
        // These ranges cause the test to fail due to floating point accuracy issues when the sign switches
        //(-1_000., 1_000.),
        //(-10_000., 10_000.),
        //(-100_000., 100_000.)
    ];

    let dimensionality = 1;
    let seed = 42;

    // Generate random data for each cardinality and min/max value where max_val > min_val
    for (cardinality, (min_val, max_val)) in cardinalities.into_iter().zip(ranges.into_iter()) {
        let data = random_data::random_tabular(
            dimensionality,
            cardinality,
            min_val,
            max_val,
            &mut rand::rngs::StdRng::seed_from_u64(seed),
        )
        .into_iter()
        .flatten()
        .collect::<Vec<_>>();
        test_cases.push(data);
    }

    let (actual_means, actual_variances): (Vec<f64>, Vec<f64>) = test_cases
        .iter()
        .map(|values| utils::mean_variance::<f64, f64>(values))
        .unzip();

    // Calculate expected_means and expected_variances using
    // statistical::mean and statistical::population_variance
    let expected_means: Vec<f64> = test_cases.iter().map(|values| statistical::mean(values)).collect();
    let expected_variances: Vec<f64> = test_cases
        .iter()
        .zip(expected_means.iter())
        .map(|(values, &mean)| statistical::population_variance(values, Some(mean)))
        .collect();

    actual_means.iter().zip(expected_means.iter()).for_each(|(&a, &b)| {
        assert!(
            float_cmp::approx_eq!(f64, a, b, ulps = 2),
            "Means not equal. Actual: {}. Expected: {}. Difference: {}.",
            a,
            b,
            a - b
        );
    });

    actual_variances
        .iter()
        .zip(expected_variances.iter())
        .for_each(|(&a, &b)| {
            assert!(
                float_cmp::approx_eq!(f64, a, b, epsilon = 3e-3),
                "Variances not equal. Actual: {}. Expected: {}. Difference: {}.",
                a,
                b,
                a - b
            );
        });
}

#[test]
fn test_standard_deviation() {
    let data = [2., 4., 4., 4., 5., 5., 7., 9.];
    let std = utils::standard_deviation::<f32, f32>(&data);
    assert!((std - 2.).abs() < 1e-6);
}
